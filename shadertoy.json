[{"ver":"0.1","info":{"id":"Ms2SD1","date":"1411752810","viewed":169162,"name":"Seascape","username":"TDM","description":"fully-procedural sea surface computing. without textures.<br\/><br\/>Android version: https:\/\/play.google.com\/store\/apps\/details?id=com.nature.seascape","likes":422,"published":1,"flags":0,"tags":["procedural","noise","waves","sea","water","subsurface"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/*\n\"Seascape\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*\/\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\nfloat EPSILON_NRM\t= 0.1 \/ iResolution.x;\n\n\/\/ sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat SEA_TIME = iGlobalTime * SEA_SPEED;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n\/\/ math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\/\/ lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) \/ (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\/\/ sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,2.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.4;\n    return ret;\n}\n\n\/\/ sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n\/\/ tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm\/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n\/\/ main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;    \n    float time = iGlobalTime * 0.3 + iMouse.x*0.01;\n        \n    \/\/ ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.15;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    \/\/ tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    \/\/ color\n    vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.05,dir.y),0.3));\n        \n    \/\/ post\n\tfragColor = vec4(pow(color,vec3(0.75)), 1.0);\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XslGRr","date":"1361810389","viewed":64494,"name":"Clouds","username":"iq","description":"Raymarching some fbm (you can move the mouse around). This is my first shader in the \"one shader a week for a year\" challenge that I have committed to.","likes":467,"published":3,"flags":1,"tags":["procedural","3d","raymarching","volumetric","lod","vr"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Volumetric clouds. It performs level of detail (LOD) for faster rendering\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nfloat map4( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iGlobalTime;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q );;\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nvec4 integrate( in vec4 sum, in float dif, in float den, in vec3 bgcol, in float t )\n{\n    \/\/ lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3)*dif;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    \/\/ front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3  pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a > 0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif =  clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); sum = integrate( sum, dif, den, bgcol, t ); } t += max(0.05,0.02*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.0;\n\n    MARCH(30,map5);\n    MARCH(30,map4);\n    MARCH(30,map3);\n    MARCH(30,map2);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\n    \/\/ clouds    \n    vec4 res = raymarch( ro, rd, col );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    \/\/ sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/ iResolution.y;\n\n    vec2 m = iMouse.xy\/iResolution.xy;\n    \n    \/\/ camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.4*m.y, cos(3.0*m.x)));\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragColor = render( fragRayOri, fragRayDir );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsX3RB","date":"1372830991","viewed":60478,"name":"Volcanic","username":"iq","description":"An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.  I can't wait for Shadertoy to have multipass rendering...","likes":233,"published":3,"flags":0,"tags":["procedural","3d","raymarching","noise","distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture2D( iChannel0, (uv+ 0.5)\/256.0, -100.0 ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture2D( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture2D( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture2D( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture2D( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture2D( iChannel0, (uv+118.4)\/256.0, -100.0 ).x;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat displacement( vec3 p )\n{\n\tp += vec3(1.0,0.0,0.8);\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p ); \n\t\n\tfloat n = noise( p*3.5 );\n    f += 0.03*n*n;\n\t\n    return f;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 30.0;\n    float t = 0.1;\n    for( int i=0; i<160; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( h<(0.001*t) || t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iGlobalTime,0.0);\n\t\n\tfloat d;\n    d  = 0.5000*noise( q ); q = q*2.02;\n    d += 0.2500*noise( q ); q = q*2.03;\n    d += 0.1250*noise( q ); q = q*2.01;\n    d += 0.0625*noise( q );\n\t\t\n\td = d - 0.55;\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), res.x );\n\tres.xyz *= 0.25;\n\tres.xyz *= 0.5 + 0.5*smoothstep( -2.0, 1.0, pos.y );\n\t\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ),6.0 );\n\tfloat t = 0.0;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tif( t>tmax || sum.w>0.95 ) break;\/\/continue;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n\t\t\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.02, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.5*.1*time*1.5), 1.5, 16.0*sin(0.1+0.5*0.11*time*1.5) );\n\t\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n\tfloat time = 2.7+iGlobalTime + off;\n\/\/time =35.0;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n\t\/\/ta.y *= 0.3 + 0.25*cos(0.11*time);\n\tta.y *= 0.35 + 0.25*sin(0.09*time);\n\tfloat roll = 0.3*sin(1.0+0.07*time);\n\t\/\/ camera2world transform\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray    \n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = cam * normalize(vec3(p.xy,2.1));\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.32,0.36,0.4) - rd.y*0.4;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\n    col *= 0.9;\n\n\tvec3 bcol = col;\n    \n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\n\t\tvec3 bn = -1.0 + 2.0*texcube( iChannel0, 3.0*pos\/4.0, nor ).xyz;\n\t\tnor = normalize( nor + 0.6*bn );\n\t\t\n\t\tfloat hh = 1.0 - smoothstep( -2.0, 1.0, pos.y );\n\n        \/\/ lighting\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.01,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\n\t\tfloat amb = 1.0;\n\n\t\tcol = vec3(0.8);\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n\n        \/\/ surface shading\/material\t\t\n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\t\tvec3 verde = vec3(1.0,0.9,0.2);\n\t\tverde *= texture2D( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*verde, hh );\n\t\t\n\t\tfloat vv = smoothstep( 0.0, 0.8, nor.y )*smoothstep(0.0, 0.1, pos.y-0.8 );\n\t\tverde = vec3(0.2,0.45,0.1);\n\t\tverde *= texture2D( iChannel2, 30.0*pos.xz ).xyz;\n\t\tverde += 0.2*texture2D( iChannel2, 1.0*pos.xz ).xyz;\n\t\tvv *= smoothstep( 0.0, 0.5, texture2D( iChannel2, 0.1*pos.xz + 0.01*nor.x ).x );\n\t\tcol = mix( col, verde*1.1, vv );\n\t\t\n        \/\/ light\/surface interaction\t\t\n\t\tcol = lin * col;\n\t\t\n\t\t\/\/ atmospheric\n\t\tcol = mix( col, (1.0-0.7*hh)*bcol, 1.0-exp(-0.00006*t*t*t) );\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= 1.3*vec3(1.06,1.1,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdX3Rr","date":"1360495251","viewed":56937,"name":"Elevated","username":"iq","description":"A raymarched version of my demo Elevated from 2009","likes":277,"published":3,"flags":1,"tags":["procedural","3d","raymarching","distancefield","terrain","vr"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SC (250.0)\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture2D(iChannel0,(p+vec2(0.5,0.5))\/256.0,-100.0).x;\n\tfloat b = texture2D(iChannel0,(p+vec2(1.5,0.5))\/256.0,-100.0).x;\n\tfloat c = texture2D(iChannel0,(p+vec2(0.5,1.5))\/256.0,-100.0).x;\n\tfloat d = texture2D(iChannel0,(p+vec2(1.5,1.5))\/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat detailH( in vec2 x )\n{\n    float d = 0.0;\/\/50.0*texture2D( iChannel2, x*0.03\/SC, 0.0 ).x;\n    return d + 0.5*texture2D( iChannel2, x*2.0\/SC, 0.0 ).x;\n}\n\nfloat detailM( in vec2 x )\n{\n    float d = 0.0;\/\/50.0*texture2D( iChannel2, x*0.03\/SC, 0.0 ).x;\n    return d;\n}\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    float de = detailH(x);\n\treturn SC*100.0*a - de;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn SC*100.0*a - detailH(x);\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn SC*100.0*a;\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<256; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    \/\/ real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture2D( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture2D( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \/\/ bounding plane\n    float tmin = 1.0;\n    float tmax = 1000.0*SC;\n#if 1\n    float maxh = 300.0*SC;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = interesct( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        \/\/ sky\t\t\n\t\tcol = vec3(0.3,.55,0.8)*(1.0-0.8*rd.y)*0.9;\n        \/\/ sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        \/\/ clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc\/SC)) );\n        \/\/ horizon\n        col = mix( col, vec3(0.7,0.75,0.8), pow( 1.0-max(rd.y,0.0), 8.0 ) );\n\t}\n\telse\n\t{\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \/\/nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture2D(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        \n        \/\/ rock\n\t\tfloat r = texture2D( iChannel0, (7.0\/SC)*pos.xz\/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture2D(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)\/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\n\t\t\/\/ snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y\/SC + 25.0*fbm(0.01*pos.xz\/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         \/\/ lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*20.0,light1);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,0.80)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(light1,ref), 0.0, 1.0),16.0);\n        col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n\t\t\/\/ fog\n        \/\/float fo = 1.0-exp(-0.000004*t*t\/(SC*SC) );\n        float fo = 1.0-exp(-0.001*t\/SC );\n        vec3 fco = 0.7*vec3(0.5,0.7,0.9) + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n\n        \/\/ sun scatter\n\t\tcol += 0.3*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.002*t\/SC));\n\t}\n\n    \/\/ gamma\n\tcol = pow(col,vec3(0.4545));\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy\/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x\/iResolution.y,1.0);\n\n    float time = iGlobalTime*0.15 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\n    \/\/ camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 11.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    \n\/\/ro = vec3(0.0,0.0,0.0); ro += camPath(20.0 ); ro.y += terrainM( ro.xz ) + 4.0; cr = 0.0; ta = ro + vec3(0.0,0.0,-1.0);    \n    \n    \/\/ camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ camera ray    \n\tvec3 rd = cam * normalize(vec3(s.xy,2.0));\n\n    vec3 col = render( ro, rd );\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( (xy.x+1.0)*(xy.y+1.0)*(xy.x-1.0)*(xy.y-1.0), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri;\n    ro = camPath( 20.0 );\n    ro.y += terrainM( ro.xz ) + 2.0;\n    \n    fragColor = vec4( render( ro, fragRayDir ), 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdX3zr","date":"1360969512","viewed":51066,"name":"Flame","username":"XT95","description":"Simple flame in distance field.","likes":313,"published":3,"flags":0,"tags":["3d","distancefield","transparency"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"float noise(vec3 p) \/\/Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n\treturn d + (noise(p+vec3(.0,iGlobalTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n}\n\nfloat scene(vec3 p)\n{\n\treturn min(100.-length(p) , abs(flame(p)) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(flame(p) < .0)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)\/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = -1.0 + 2.0 * fragCoord.xy \/ iResolution.xy;\n\tv.x *= iResolution.x\/iResolution.y;\n\t\n\tvec3 org = vec3(0., -2., 4.);\n\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n\t\n\tvec4 p = raymarch(org, dir);\n\tfloat glow = p.w;\n\t\n\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n\t\n\tfragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n\t\/\/fragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n}\n\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xds3zN","date":"1364255835","viewed":40732,"name":"Raymarching - Primitives","username":"iq","description":"A set of primitives and combination functions, for reference. More info here: <a href=\"http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\"  class=\"regular\" target=\"_blank\">http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm<\/a>","likes":266,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefields","primitives"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ A list of usefull distance function to simple primitives, and an example on how to \n\/\/ do some interesting boolean operations, repetition and displacement.\n\/\/\n\/\/ More info here: http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)\/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n  return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\/\/----------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n\/\/----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n\tres = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n\tres = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n\tres = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n\tres = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n\tres = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n\tres = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n\tres = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n\n    res = opU( res, vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS(\n\t\t             sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n\t                 sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)\/6.2831,\n\t\t\t\t\t\t\t\t\t\t\t  pos.y,\n\t\t\t\t\t\t\t\t\t\t\t  0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))),\n\t\t\t\t\t\t\t\t\t     vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n\tres = opU( res, vec2( 0.7*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + \n\t\t\t\t\t                   0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), \n                                       65.0 ) );\n\tres = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n\n    res = opU( res, vec2(sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n\n    res = opU( res, vec2(sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        \/\/ lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iGlobalTime;\n\n\t\/\/ camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sfGWX","date":"1380117630","viewed":39541,"name":"Wolfenstein 3D","username":"reinder","description":"Experiment to generate some well-known textures in a textureless shader. This shader is work in progress. <br\/>Feel free to add comments, suggestions or a clever method to generate the most used wall texture in Wolfenstein (irregular grey bricks).","likes":77,"published":3,"flags":0,"tags":["procedural","voxel","textures","wolfenstein"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ Wolfenstein. Created by Reinder Nijhoff 2013\n\/\/ @reindernijhoff\n\/\/\n\/\/ https:\/\/www.shadertoy.com\/view\/4sfGWX\n\/\/\n\n#define NUM_MATERIALS 3\n#define NUM_OBJECTS 1\n#define SECONDS_IN_ROOM 3.\n#define ROOM_SIZE 10.\n#define MAXSTEPS 17\n#define MATERIAL_DOOR 200\n#define MATERIAL_DOORWAY 201\n\n#define COL(r,g,b) vec3(r\/255.,g\/255.,b\/255.)\n\nfloat time = iGlobalTime+40.;\nvec3 rdcenter;\n\n\/\/----------------------------------------------------------------------\n\/\/ Math functions\n\nfloat hash( const float n ) {\n    return fract(sin(n*14.1234512)*51231.545341231);\n}\nfloat hash( const vec2 x ) {\n\tfloat n = dot( x, vec2(14.1432,1131.15532) );\n    return fract(sin(n)*51231.545341231);\n}\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\nbool intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\n\tvec2 p = ro.xz;\tvec2 r = rd.xz;\n\tvec2 q = a-p;\tvec2 s = b-a;\n\tfloat rCrossS = crossp(r, s);\n\t\n\tif( rCrossS == 0.){\n\t\treturn false;\n\t}\n\tdist = crossp(q, s) \/ rCrossS;\n\tu = crossp(q, r) \/ rCrossS;\n\t\n\tif(0. <= dist && 0. <= u && u <= 1.){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Material helper functions\n\nfloat onCircle( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 4.*(radius - distance(c,centre)), 0., 1. );\n}\nfloat onCircleLine( const vec2 c, const vec2 centre, const float radius ) {\n\treturn clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );\n}\nfloat onLine( const float c, const float b ) {\n\treturn clamp( 1.-abs(b-c), 0., 1. );\n}\nfloat onBand( const float c, const float mi, const float ma ) {\n\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\n}\nfloat onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.x, b )*onBand( c.y, mi, ma );\n}\nfloat onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {\n\treturn onLine( c.y, b )*onBand( c.x, mi, ma );\n}\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\n\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\n}\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\n\tfloat xl = clamp( (c.x-lt.x)\/size, 0., 1. ); \n\tfloat xr = clamp( (rb.x-c.x)\/size, 0., 1. );\t\n\tfloat yt = clamp( (c.y-lt.y)\/size, 0., 1. ); \n\tfloat yb = clamp( (rb.y-c.y)\/size, 0., 1. );\t\n\n\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\n}\nvec3 addKnob( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\n\tvec2 lv = normalize( centre-c );\n\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircle(c, centre, radius ) );\n}\nfloat stepeq( float a, float b ) { \n\treturn step( a, b )*step( b, a );\n}\n\/\/----------------------------------------------------------------------\n\/\/ Generate materials!\n\nvoid getMaterialColor( const int material, in vec2 uv, const float decorationHash, out vec3 col ) {\t\n\tvec3 fgcol;\n\t\n\tuv = floor( mod(uv+64., vec2(64.)) );\n\tvec2 uvs = uv \/ 64.;\n\t\n\t\/\/ basecolor\n\tvec3 basecol = vec3( mix(55.\/255.,84.\/255.,uvs.y ) );\t\n\tfloat br = hash(uv);\n\tcol = basecol;\n\/\/ grey bricks\n\tif( material == 0 || material == 1 ) {\n\t\tvec2 buv = vec2( mod(uv.x+1. + (floor((uv.y+1.) \/ 16.) * 16.), 32.) , mod( uv.y+1., 16.) );\n\t\tfloat bbr = mix( 190.\/255., 91.\/255., (buv.y)\/14. ) + 0.05*br;\n\t\tif ( buv.x < 2. || buv.y < 2.) {\n\t\t\tbbr = 72.\/255.; \n\t\t}\n\t\tcol = vec3(bbr*0.95);\n\t\tcol = addBevel( buv, vec2(1.,1.), vec2( 31.5, 15.), 2., 0.35, 1., 1., col);\n\t\/\/ blue wall\n\t\tif( material == 1 ) {\n\t\t\tcol *= 1.3*COL(11.,50.,209.);\n\t\t\tcol = mix( col, COL(2.,15.,86.), onBand(uv.y,14.,49.));\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.9+0.1*br), onBand(uv.y,16.,47.));\n\t\t\tcol = mix( col, COL(3.,25.,122.), onBand(uv.y,21.,42.));\n\t\t\tcol = addBevel( uv, vec2(-1.,16.), vec2( 65., 21.), 1., 0.35, 1., 1., col);\n\t\t\tcol = addBevel( uv, vec2(-1.,43.), vec2( 65., 48.), 1., 0.35, 1., 1., col);\n\t\t\t\n\t\t\tcol = mix( col, COL(2.,11.,74.), onRect(uv, vec2(22.,22.), vec2(42.,42.)));\t\t\n\t\t\tcol = mix( col, COL(9.,44.,185.)*(0.95+0.1*br), onRect(uv, vec2(22.,23.), vec2(42.,40.)));\n\t\t\tcol = addBevel( uv, vec2(22.,23.), vec2(42.,40.), 1., 0.2, -1., 1., col);\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.x-26.)\/3.), onRect(uv, vec2(26.,23.), vec2(29.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)\/2.), onRect(uv, vec2(22.,34.), vec2(29.,36.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-27.)\/2.), onRect(uv, vec2(35.,27.), vec2(42.,29.)));\n\t\t\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)\/8.), onRect(uv, vec2(35.,34.), vec2(38.,42.)));\n\t\t}\n\t}\n\/\/ wooden wall\n\telse if( material == 2 ) {\n\t\tfloat mx = mod( uv.x, 64.\/5. ); \n\t\tfloat h1 = hash( floor(uv.x\/(64.\/5.)) );\n\t\tfloat h2 = hash( 1.+1431.16*floor(uv.x\/(64.\/5.)) );\n\t\tcol = mix( COL(115.,75.,43.),COL( 71.,56.,26.), smoothstep( 0.2, 1., (0.7+h2)*abs(mod( h2-uv.y*(0.05+0.1*h2)+(1.+h1+h2)*sin(mx*(0.1+0.2*h2)), 2. )-1.) ) );\n\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x)\/2.), step(uv.x,2.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-10.)\/2.), step(10.,uv.x)*step(uv.x,12.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-26.)\/2.), step(26.,uv.x)*step(uv.x,28.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-40.)\/2.), step(40.,uv.x)*step(uv.x,42.) );\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-54.)\/2.), step(54.,uv.x)*step(uv.x,56.) );\n\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x- 8.)), step( 8.,uv.x)*step(uv.x,9.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-24.)), step(24.,uv.x)*step(uv.x,25.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-38.)), step(38.,uv.x)*step(uv.x,39.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-52.)), step(52.,uv.x)*step(uv.x,53.) );\n\t\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-62.)), step(62.,uv.x) );\n\t\t\n\t\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.y)\/2.), step(uv.y,2.) );\n\t\tcol *= 1.-0.3*stepeq(uv.y,3.);\n\t}\n\/\/ door\n\telse if( material == MATERIAL_DOOR ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)\/(1.3-0.8*uvs.x)) ) );\n\t\tfgcol = addBevel( uv, vec2(-1.,1.), vec2(62.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uv, vec2( 6.,6.), vec2(57.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( mod( uv, vec2(8.) ), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uv,  vec2( 6.,6.), vec2(57.,57.)) ) ;\n\t\t\n\t\t\/\/knob\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 13.5, 28.5 ), vec2( 22.5, 44.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(44.,44.,44.),COL(152.,152.,152.), ((uv.x+(43.-uv.y)-15.)\/25. ) ), onRect( uv, vec2( 15., 27. ), vec2( 24., 43. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 15., 27. ), vec2( 24., 43. ), 1., 0.45, 1., 1., fgcol);\t\n\t\tfgcol = mix( fgcol, addKnob( mod( uv, vec2(6.) ), vec2(4.25,5.5), 1.15, 0.75, fgcol ), onRect( uv,  vec2( 15., 27. ), vec2( 24., 43. ) ) ) ;\n\n\t\tfgcol *= 1.-0.5*onRect( uv, vec2( 16.5, 33.5 ), vec2( 20.5, 38.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(37.-uv.y)-18.)\/7. ) ), onRect( uv, vec2( 18., 33. ), vec2( 21., 37. ) ) );\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onRect( uv, vec2( 19., 34. ), vec2( 20., 35.7 ) ) );\n\n\t\tfgcol *= 1.-0.2*onRect( uv, vec2( 6.5, 29.5 ), vec2( 10.5, 41.5 ) );\n\t\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(40.-uv.y)-9.)\/13. ) ), onRect( uv, vec2( 9., 29. ), vec2( 11., 40. ) ) );\n\t\tfgcol = addBevel( uv, vec2( 9., 29. ), vec2( 11., 40. ), 0.75, 0.5, 1., 1., fgcol);\t\n\t\t\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\/\/ doorway\n\telse if( material == MATERIAL_DOORWAY ) {\n\t\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)\/(1.3-0.8*uvs.x)) ) );\n\t\tvec2 uvhx = vec2( 32.-abs(uv.x-32.), uv.y );\n\t\tfgcol = addBevel( uvhx, vec2(-1.,1.), vec2(28.,66.), 2., 0.4, -1., -1., fgcol);\n\t\tfgcol = addBevel( uvhx, vec2( 6.,6.), vec2(23.,57.), 2.25, 0.5, -1., -1., fgcol);\t\n\t\tfgcol = mix( addKnob( vec2( mod( uvhx.x, 22. ), mod( uvhx.y, 28. )), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uvhx,  vec2( 6.,6.), vec2(24.,57.)) ) ;\n\t\tfgcol = mix( fgcol, vec3(0.), onRect( uv, vec2( 29., 1.), vec2( 35., 63.) ) );\n\t\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\t\n\t}\n\t\n\/\/ prison door\t\n\tif( decorationHash > 0.93 && material < (NUM_MATERIALS+1) ) {\t\n\t\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\n\t\/\/ shadow\n\t\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\n\t\/\/ hinge\n\t\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\n\t\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\n\t\t\n\t\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \n\t\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \n\t\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\n\t\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\n\t\t\n\t\tfgcol = COL(72.,72.,72.);\n\t\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\n\t\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\n\t\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\n\t\t\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)\/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\n\t\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)\/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\n\t\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\n\n\t\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)\/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\n\t\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\n\n\t\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\n\t}\n\/\/ flag\n\telse if( decorationHash > 0.63 && material < (NUM_MATERIALS+1) ) {\t\t\n\t\tvec2 uvc = uv-vec2(32.,30.);\n\t\n\t\/\/ shadow\t\n\t\tvec4 shadowcoords = vec4( 14., 7., \n\t\t\t\t\t\t\t\t  54., max( 56. + sin( uv.x*0.32-1. ),56.) ); \n\t\tcol *= 1.-0.3*onRect( uv,  vec2( 6., 6. ), vec2( 61., 7. ) );\n\t\tcol *= 1.-0.3*clamp( 0.25*(56.-uv.x), 0., 1.)*onRect( uv, shadowcoords.xy, shadowcoords.zw );\n\n\t\/\/ rod\n\t\tcol = mix( col, COL(250.,167.,98.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 4., 6.5 ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentY( uv, 5., 4., 60. ) );\n\t\tcol = mix( col, COL(155.,76.,17.), onLineSegmentY( uv, 6., 4., 60. ) );\n\t\tcol = mix( col, COL(202.,96.,25.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 26., 28. ) );\n\t\tcol = mix( col, COL(251.,242.,53.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 3., 7. ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 4.3, 5.5 ) );\n\t\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 5.3, 5.5 ) );\n\t\tcol = mix( col, COL(0.,0.,0.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 18.3, 19.5 ) );\n\n\t\/\/ flag\t\n\t\tvec4 flagcoords = vec4( 13., min( 9.5 - pow(5.5* (uvs.x-0.5), 2.), 9. ), \n\t\t\t\t\t\t    51., max( 55. + sin( uv.x*0.4+2.7 ),55.) ); \n\t\n\t\tfgcol = COL(249.,41.,27.);\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onBand( min(abs(uvc.x), abs(uvc.y)), 2., 4. ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onLine( min(abs(uvc.x), abs(uvc.y)), 3. ) );\t\t\n\t\t\n\t\tfgcol = mix( fgcol, COL(255.,255.,255.), onCircle( uv, vec2(32.,30.), 12.5 ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 11. ) );\t\n\t\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 9. ) );\n\t\t\n\t\tvec2 uvr = vec2( (uvc.x-uvc.y)*0.7071, (uvc.y+uvc.x)*0.7071)*sign( uvc.x+0.5 );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(1.,4.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-4.2, 4.2), vec2(1.,6.15) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(4.,1.) ) );\n\t\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2( 4.2,-1.), vec2(6.15,4.2) ) );\n\t\n\t\tfgcol *= (0.8+0.2*sin( uv.x*0.4+2.7 ));\n\t\tfgcol *= (0.8+0.2*clamp( 0.5*(uv.y-7.), 0., 1.));\n\t\n\t\/\/ mix flag on background\n\t\tcol = mix( col, fgcol, onRect( uv, flagcoords.xy, flagcoords.zw ) );\n\t}\n\t\n\/\/ fake 8-bit color palette and dithering\t\n\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)\/32.)*32.)\/32.;\n}\nbool getObjectColor( const int object, in vec2 uv, inout vec3 icol ) {\n\tuv = floor( mod(uv, vec2(64.)) );\n\tvec2 uvs = uv \/ 64.;\n\tvec3 col = vec3(20.\/255.);\n\tfloat d;\n\t\n\/\/ only a lamp for now\n\t\n\t\/\/ lamp top\n\td = distance( uv*vec2(1.,2.), vec2(28.1, 5.8)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( d\/8.-0.2, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,13.6), 11.7 )*step( uv.y, 6. )); \n\tcol = mix( col, COL(9.,75.,6.), onCircleLine( uv, vec2(31.,14.), 11.6 ) *\n\t\t\t  step( length(uv-vec2(31.,13.6)), 11.7 )*step( uv.y, 6. ) );\n\tcol = mix( col, COL(100.,100.,100.), onLine( abs(uv.x-31.), 1. )*step( uv.y, 1. ) );\n\tcol = mix( col, COL(140.,140.,140.), onLine( abs(uv.x-31.), 0.25 )*step( uv.y, 1. )*step( 1., uv.y ) );\n\t\n\t\/\/ lamp bottom\n\td = distance( uv*vec2(1.,2.), vec2(30.5, 6.5)*vec2(1.,2.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( abs(uv.x-31.)\/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 7.) );\n\tcol = mix( col, mix( COL(41.,250.,46.), COL(16.,123.,17.), clamp( abs(uv.x-31.)\/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 8.) );\n\tcol = mix( col, mix( COL(133.,250.,130.), COL(22.,150.,23.), clamp( abs(uv.x-31.)\/4.-0.75, 0., 1. )), step( abs(uv.x-31.), 7. )*stepeq( uv.y, 9.) );\n\n\tcol = mix( col, mix( COL(255.,251.,187.), col, clamp( d\/4.5-0.6, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 10.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\tcol = mix( col, mix( COL(255.,255.,255.), col, clamp( d\/4.-0.7, 0., 1.) ), \n\t\t\t  onCircle(uv, vec2(31.,1.), 7.2 )*step( uv.y, 8. )*step( 7., uv.y )); \n\t\t\n\t\/\/ floor\n\td = distance( vec2(mod(uv.x, 32.),uv.y)*vec2(1.5,30.\/3.), vec2(16., 61.5)*vec2(1.5,30.\/3.) );\n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(d\/15.-0.5, 0., 1.) ), step(d,24.5)); \n\tcol = mix( col, mix( COL(124.,124.,124.), COL(140.,140.,140.), clamp((uv.y-59.)\/1., 0., 1.)), step(59.,uv.y)*step(uv.x, 57.)*step(7.,uv.x)); \n\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(abs(32.-uv.x)\/10.-2., 0., 1.)), step(uv.y, 62.)*step(62.,uv.y)*step(uv.x, 61.)*step(3.,uv.x)); \n\tcol = mix( col, mix( COL(152.,152.,152.), COL(124.,124.,124.), clamp(abs(32.-uv.x)\/10.-2.25, 0., 1.)), step(uv.y, 61.)*step(61.,uv.y)*step(uv.x, 59.)*step(5.,uv.x)); \n\n\tcol = floor( (col)*32.)\/32.;\n\tif( any(notEqual(col, vec3(floor((20.\/255.)*32.)\/32.))) ) {\n\t\ticol = col;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Proocedural MAP functions\n\nbool isWall( const vec2 vos ) {\n\treturn vos.y<0.4*ROOM_SIZE || vos.y>2.75*ROOM_SIZE || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(0.,0.) ) );\n}\nbool isDoor( const vec2 vos ) {\n\treturn isWall(vos) && ((hash(vos)>0.75 &&  any( equal( mod( vos, vec2( ROOM_SIZE*0.5 ) ), vec2(2.) ) )) \n\t\t    || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(ROOM_SIZE*0.5) ) )); \n}\nbool isObject( const vec2 vos ) {\n\treturn hash( vos*10. ) > 0.95;\n}\nbool map( const vec2 vos ) {\n\treturn isObject( vos ) || isWall( vos );\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Render MAP functions\n\nbool intersectSprite( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 nor, out vec2 uv ) {\n\tfloat dist, u;\n\tvec2 a = vos.xz + nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tvec2 b = vos.xz - nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\n\tif( intersectSegment( ro, rd, a, b, dist, u) ) {\n\t\tuv.x = u; uv.y = 1.-(ro+dist*rd).y;\n\t\tif( sign(nor.x)<0. ) uv.x = 1.-uv.x;\n\t\treturn uv.y>0.&&uv.y<1.;\n\t}\n\treturn false;\n}\nint getMaterialId( const vec2 vos ) {\n\treturn int( mod( 521.21 * hash( floor((vos-vec2(0.5))\/ROOM_SIZE )  ), float(NUM_MATERIALS)) );\n}\nbool getColorForPosition( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 pos, const vec3 nor, inout vec3 col ) {\t\n\tvec2 uv;\n\n\tif( isWall( vos.xz ) ) {\n\t\tif( isDoor( vos.xz ) ) {\n\t\t\tif( intersectSprite( ro, rd, vos+nor*0.03, nor, uv ) ) {\n\t\t\t\t\/\/ open the door\n\t\t\t\tuv.x -= clamp( 2.-0.75*distance( ro.xz, vos.xz+vec2(0.5) ), 0., 1.);\n\t\t\t\tif( uv.x > 0. ) {\n\t\t\t\t\tgetMaterialColor( MATERIAL_DOOR, uv*64., 0., col );\n\t\t\t\t\treturn true;\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t\treturn false;\n\t\t}\n\t\t\/\/ a wall is hit\n\t\tif( pos.y <= 1. && pos.y >= 0. ) {\n\t\t\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\n    \t\tfloat sha = 0.6 + 0.4*abs(nor.z);\t\t\n\t\t\tgetMaterialColor( isDoor( vos.xz+nor.xz )?MATERIAL_DOORWAY:getMaterialId(vos.xz), mpos*64., hash( vos.xz ), col );\n\t\t\tcol *= sha;\n\t\t\treturn true;\n\t\t}\n\t\treturn true;\n\t}\n\tif( isObject( vos.xz ) && !isWall( vos.xz+vec2(1.,0.) ) && !isWall( vos.xz+vec2(-1.,0.) )\n\t    && !isWall( vos.xz+vec2(0.,-1.) ) && !isWall( vos.xz+vec2(0.,1.) ) &&\n\t    intersectSprite( ro, rd, vos, rdcenter, uv ) ) {\n\t\treturn getObjectColor( 0, uv*64., col );\n\t}\n\treturn false;\n}\n\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = 0.0;\n\tvec3 mm = vec3(0.0);\n\tbool hit = false;\n\t\n\tfor( int i=0; i<MAXSTEPS; i++ )\t{\n\t\tif( hit ) continue;\n\t\t\n\t\tmm = step(dis.xyz, dis.zyx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t\t\n\t\tif( map(pos.xz) ) { \n\t\t\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\t\t\tfloat t = max ( mini.x, mini.z );\t\t\t\n\t\t\thit = getColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), col );\n\t\t}\n\t}\n\treturn hit;\n}\n\n\/\/----------------------------------------------------------------------\n\/\/ Some really ugly code\n\n#define CCOS(a) cos(clamp(a,0.,1.)*1.57079632679)\n#define CSIN(a) sin(clamp(a,0.,1.)*1.57079632679)\nvec3 path( const float t ) {\n\tfloat tmod = mod( t\/SECONDS_IN_ROOM, 8. );\n\tfloat tfloor = floor( tmod );\n\t\n\tvec3 pos = vec3( 4.*ROOM_SIZE*floor(t\/(SECONDS_IN_ROOM*8.))+0.5, 0.5, 0.5*ROOM_SIZE+0.5 );\t\n\treturn pos + ROOM_SIZE*vec3(\n\t\tclamp(tmod,0.,1.)+clamp(tmod-4.,0.,1.)+0.5*(2.+CSIN(tmod-1.)-CCOS(tmod-3.)+CSIN(tmod-5.)-CCOS(tmod-7.)), 0.,\n\t\tclamp(tmod-2.,0.,1.)-clamp(tmod-6.,0.,1.)+0.5*(-CCOS(tmod-1.)+CSIN(tmod-3.)+CCOS(tmod-5.)-CSIN(tmod-7.)) );\n}\n\n\n\/\/----------------------------------------------------------------------\n\/\/ Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+0.1 );\n\t\n    rdcenter = rotate( normalize( ta - ro), 0.3*cos(time*0.75) );\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\n    vec3 vv = normalize(cross(rdcenter,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*rdcenter );\n\t\n\tvec3 col = rd.y>0.?vec3(56.\/255.):vec3(112.\/255.);\n\tcastRay( ro, rd, col );\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsSXzD","date":"1410462817","viewed":33886,"name":"E1M1 - Hangar","username":"P_Malin","description":"The start area of Doom E1M1.<br\/>Hold down the mouse button and drag the mouse to move.<br\/>Where you click relative to the center of the screen sets the view direction.<br\/><br\/>Also, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD","likes":75,"published":3,"flags":8,"tags":["doom","e1m1","hangar"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ E1M1 - Hangar\n\/\/ by @P_Malin\n\n\/\/ Procedural version of Doom E1M1\n\n\/\/ The start area of Doom E1M1.\n\/\/ Click and drag the mouse to move.\n\/\/ Where you click relative to the center of the screen sets the view direction.\n\n\/\/ Also, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD\n\n\/\/ The sectors we draw by default\n#define ENABLE_NUKAGE_SECTORS\n#define ENABLE_START_SECTORS\n\n\/\/ Adding this compiles with \"Unknown Error\" on some machines. Uncomment if you are feeling lucky.\n\/\/#define ENABLE_SECTOR_31\n\n\/\/ Some additional sectors, may need to comment out some of the default ones\n\/\/#define ENABLE_EXTRA_NUKAGE_SECTORS\n\/\/#define ENABLE_MISC_SECTORS\n\n#define ENABLE_SPRITES\n\n#define DEMO_CAMERA\n#define INTRO_EFFECT\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define PIXELATE_IMAGE\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\/\/#define DISCARD_BACKGROUND\n\n\/\/#define DRAW_COMPASS\n\n\/\/ Add walls to close entrances to sectors we are not rendering\n#ifndef ENABLE_EXTRA_NUKAGE_SECTORS\n\t#define CLOSE_NUKAGE_SECTOR\n#endif\n#ifndef ENABLE_SECTOR_31\n\t#define CLOSE_START_SECTOR\n#endif\n\n#define FAR_CLIP 10000.0\n\nconst vec2 vFakeResolution = vec2(320.0, 240.0);\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\n\/\/ Light level adjustment to East-West and North-South walls\nconst float kC = (1.0 \/ 16.0);\n\nvec3 SampleTexture( const in float fTexture, const in vec2 vUV );\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo );\nfloat hash(float p);\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\nvec3 Quantize( const in vec3 col )\n{\n\treturn floor( col * 48.0 + 0.5 ) * (1.0 \/ 48.0);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    \/\/return cross( vec3(vA, 0.0), vec3(vB, 0.0) ).z;\n  \treturn vA.x * vB.y - vA.y * vB.x;\n\n    \/\/return dot(vA * vB.yx, vec2(1.0, -1.0)); \n}\n\nvec3 g_vRayOrigin;\nvec3 g_vRayDir;\nvec2 g_vSpriteDir;\n\nvoid BeginSector( out vec4 vSectorState, const in vec2 vSectorHeights )\n{\n    \/\/ store the infinite floor-ceiling plane intersect depth in vSectorState.xy\n    vSectorState.xy = (vSectorHeights - g_vRayOrigin.y) \/ g_vRayDir.y;   \n    vSectorState.zw = vec2(0.0);\n}\n\n\/\/ Intersect a sidedef that meets another sector with the same floor and ceiling height\nvoid Null( inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n   \tif((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n    \tvSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n    }\n}\n\nvoid Wall( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in float fTexture )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n\n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {        \n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * fLen, fHitY, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nvoid Open( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in int iUpperHeight, const in float fLowerTexture, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    float fLowerHeight = float(iLowerHeight);\n\t\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\nvoid Upper( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iUpperHeight, const in float fUpperTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY < vSectorHeights.y )\n            {           \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\n\nvoid Lower( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in float fLowerTexture )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fLowerHeight = float(iLowerHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n\tfloat fDenom = Cross2d( g_vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( fHitY > vSectorHeights.x )\n            {           \n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n            }\n        }\n    }\n}\n\nvoid EndSector( inout float fClosestT, inout vec4 vHitInfo, in vec4 vSectorState, const in float fLightLevel, const in vec2 vFloorCeilingTextures )\n{\n    \/\/ Test the even-odd state of our sector floor\/ceiling in-out values\n    vec2 vInOutTest = fract( vSectorState.zw * 0.5 ) * 2.0;\n\n    if( fClosestT > vSectorState.x )\n    {\n        if((vInOutTest.x > 0.5) && (vSectorState.x > 0.0))\n        {\n            vec3 vFloorPos = g_vRayOrigin + g_vRayDir * vSectorState.x;        \n            if( g_vRayOrigin.y > vFloorPos.y )\n            {\n                fClosestT = vSectorState.x;\n                vHitInfo = vec4( vFloorPos.xz, fLightLevel, vFloorCeilingTextures.x);\n            }\n        }\n    }\n\n    if( fClosestT > vSectorState.y )\n    {\n        if((vInOutTest.y > 0.5) && (vSectorState.y > 0.0))\n        {\n            vec3 vCeilingPos = g_vRayOrigin + g_vRayDir * vSectorState.y;        \n            if( g_vRayOrigin.y < vCeilingPos.y )\n            {\n                fClosestT = vSectorState.y;\n                vHitInfo = vec4( vCeilingPos.xz, fLightLevel, vFloorCeilingTextures.y);\n            }\n        }            \n    }\n}\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( out float fClosestT, out vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, vec2 vSize, float fLightLevel, float fTexture )\n{\n\tvec3 vPos = vec3(iX, iY, iZ);\n\tfClosestT = FAR_CLIP;\n\tvHitInfo = vec4(0.0);\n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - g_vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( g_vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;\n\n    if(fHitT > 0.0)\n    {\n\t    float fHitU = Cross2d( vOA, g_vRayDir.xz ) * rcpdenom;\n        if((fHitU >= 0.0) && (fHitU < 1.0))\n        {\n            float fHitY = g_vRayDir.y * fHitT + g_vRayOrigin.y;\n            if( (fHitT < fClosestT) && (fHitY > vPos.y) && (fHitY < (vPos.y + vSize.y)) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * vSize.x, fHitY - vPos.y, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(57.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.8);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.y));\n\treturn fDist < 0.4;\n}\n\n#define TEX_BAR1A 32.0\n#define TEX_PLAYW 33.0\n\nvoid BarrelSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(23.0, 32.0), fLightLevel, TEX_BAR1A);\n\t\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskBarrel(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n\nvoid CorpseSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(57.0, 22.0), fLightLevel, TEX_PLAYW );\n\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskCorpseSprite(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vOrigUV = fragCoord.xy \/ iResolution.xy;\n    \n    #ifdef PIXELATE_IMAGE\n    vec2 vUV = floor(vOrigUV * vFakeResolution + 0.5) * (1.0 \/ vFakeResolution);\n    #else\n    vec2 vUV = vOrigUV;\n    #endif\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n\tconst vec2 vStart = vec2(1050, -3616);\n\n\tif(iMouse.z > 0.0)\n    {\n        vec2 vDir = normalize((abs(iMouse.zw) \/ iResolution.xy) - 0.5);\n        vec2 vOffset = (iMouse.xy - abs(iMouse.zw)) \/ iResolution.xy;\n\t\tvCameraPos.y = 30.0;\n    \tvCameraPos.xz = (vDir.yx * vec2(1.0, -1.0) * vOffset.x + vDir * vOffset.y) * 5000.0;\n        vCameraPos.xz += vStart;\n        vCameraTarget.xz = vCameraPos.xz + vDir * 10.0;\n\t    vCameraTarget.y = vCameraPos.y;\n    }\n    else\n    {\n        vCameraPos = vec3(1050, 30, -3616);\n        vCameraTarget = vec3(1050, 30, -3500);\n\n        #ifdef DEMO_CAMERA\n        float fCamTime = iGlobalTime - 5.0;\n        if(fCamTime > 0.0) fCamTime = mod(fCamTime, 33.0 - 5.0) + 5.0;\n        if(iGlobalTime==10.0) fCamTime = 0.0; \/\/ hack for shadertoy preview screen\n        vCameraTarget = mix( vCameraTarget, vec3(1834, 30, -3264), smoothstep(5.0, 10.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -3350), smoothstep(8.0, 13.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(1280, 30, -2976), smoothstep(11.0, 16.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(1280, 30, -2976), smoothstep(13.0, 19.0, fCamTime));\n        \n        vCameraTarget = mix( vCameraTarget, vec3(768, 30, -3050), smoothstep(16.0, 20.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(832, 30, -3020), smoothstep(19.0, 23.0, fCamTime));\n\n        vCameraTarget = mix( vCameraTarget, vec3(1256, 30, -3648), smoothstep(20.0, 25.0, fCamTime));\n        vCameraPos = mix( vCameraPos, vec3(768, 30, -3424), smoothstep(23.0, 28.0, fCamTime));\n        \n        vCameraPos = mix( vCameraPos, vec3(1050, 30, -3616), smoothstep(25.0, 30.0, fCamTime));\n        vCameraTarget = mix( vCameraTarget, vec3(1050, 30, -3500), smoothstep(28.0, 33.0, fCamTime));\n        #endif\n    }\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(length(vCameraPos.xz - vStart) * 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    vCameraTarget.y += fBob;\n    #endif\n\n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    g_vRayOrigin = vCameraPos;\n    g_vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n    \n    vec4 vHitInfo;\n    float fClosestT;\n\tfloat fNoFog = 0.0;\n\n\t\n    MapIntersect( fClosestT, vHitInfo );\n\n\tvec3 vForwards = normalize(vCameraTarget - vCameraPos); \n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878);\n    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878);\n    #endif\t\n\t\n\tvHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);\n\n    \/\/ sky\n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 \/ radians(180.0)) + vUV.x * 320.0;\n    float fSkyV = vUV.y * 240.0;\n    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);\n    #endif\n    \n    \/\/ fade in effect\n\t#ifdef INTRO_EFFECT\n    float fEffectOffset = max(iGlobalTime - 1.0, 0.0) - hash(vUV.x);\n    vec2 vEffectUV = vUV;\n    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);\n    \n    float fDoEffect = step(vEffectUV.y, 1.0);       \n    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);\n    fNoFog = max(fNoFog, fDoEffect);\n    #endif    \n\n\t#ifdef DISCARD_BACKGROUND    \n    if(vHitInfo.w == 0.0) discard;\n\t#endif\n    \n    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );\n    float fDepth = dot(g_vRayDir, vForwards) * fClosestT;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );\n    \n    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult);\n    #endif\n    \n    #ifdef DRAW_COMPASS\n    \/\/ a hack - assume we have never clicked the mouse before if coordinate is zero\n    if((iMouse.x > 0.5) && (iMouse.y > 0.5))\n    {\n        if(iMouse.z <= 0.0)\n        {\n            vec2 vCompassUV = vOrigUV - 0.5;\n            vCompassUV.x *= iResolution.x \/ iResolution.y;\n            float fDistNS = ((abs(vCompassUV.x) * 10.0) + abs(vCompassUV.y) - 0.05);\n            float fDistEW = ((abs(vCompassUV.y) * 10.0) + abs(vCompassUV.x) - 0.025);\n            float fDistCircle = abs(0.045 - length(vCompassUV)) * 10.0;\n            float fDist = min(min(fDistNS, fDistEW), fDistCircle);\n            \n            float fAmount = clamp(fDist * 20.0, 0.0, 1.0);\n            float fCol = step(fract((floor(vCompassUV.x) + floor(vCompassUV.y)) * 0.5), 0.25);\n            vResult = mix(vec3(fCol * 0.75 + 0.25), vResult, fAmount);\n        }\n    }\n    #endif\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n\n\/\/ Generated code follows\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\/\/ Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLAT5_5 4.0\n#define TEX_FLOOR4_8 5.0\n#define TEX_CEIL3_5 6.0\n#define TEX_TLITE6_4 7.0\n#define TEX_FLAT14 8.0\n#define TEX_FLOOR7_2 9.0\n#define TEX_STEP2 10.0\n#define TEX_TLITE6_1 11.0\n#define TEX_DOOR3 12.0\n#define TEX_LITE3 13.0\n#define TEX_STARTAN3 14.0\n#define TEX_BROWN1 15.0\n#define TEX_DOORSTOP 16.0\n#define TEX_COMPUTE2 17.0\n#define TEX_STEP6 18.0\n#define TEX_BROWN144 19.0\n#define TEX_SUPPORT2 20.0\n#define TEX_STARG3 21.0\n#define TEX_DOORTRAK 22.0\n#define TEX_SLADWALL 23.0\n#define TEX_TEKWALL4 24.0\n#define TEX_SW1COMP 25.0\n#define TEX_BIGDOOR2 26.0\n\n\/\/ Sectors\n\nvoid Sector0( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-80.0, 216.0);\n\n    BeginSector( vSS, vSH );\n    Lower( fT, vInf, vSS, 1520, -3168, 1672, -3104, 164, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1672, -3104, 1896, -3104, 224, fLt-kC, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1896, -3104, 2040, -3144, 149, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2040, -3144, 2128, -3272, 155, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2128, -3272, 2064, -3408, 150, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 2064, -3408, 1784, -3448, 282, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1784, -3448, 1544, -3384, 248, fLt, vSH, -56, TEX_BROWN144 );\n    Lower( fT, vInf, vSS, 1544, -3384, 1520, -3168, 217, fLt, vSH, -56, TEX_BROWN144 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_NUKAGE3, TEX_F_SKY1) );\n}\n\nvoid Sector1( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 216.0);\n\t\/\/ merge walls from ultimate doom secret\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 1376, -3200, 1376, -3104, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1376, -3360, 1376, -3264, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1376, -3264, 1376, -3200, 64, fLt+kC, vSH, TEX_STARTAN3);\n\tWall( fT, vInf, vSS, 1376, -3104, 1376, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1376, -2944, 1472, -2880, 115, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1856, -2880, 1920, -2920, 75, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 1520, -3168, 1672, -3104 );\n    Null( vSS, 1672, -3104, 1896, -3104 );\n    Null( vSS, 1896, -3104, 2040, -3144 );\n    Null( vSS, 2040, -3144, 2128, -3272 );\n    Null( vSS, 2128, -3272, 2064, -3408 );\n    Null( vSS, 2064, -3408, 1784, -3448 );\n    Null( vSS, 1784, -3448, 1544, -3384 );\n    Null( vSS, 1544, -3384, 1520, -3168 );\n    Wall( fT, vInf, vSS, 2736, -3360, 2736, -3648, 288, fLt+kC, vSH, TEX_STARTAN3);\n#ifdef CLOSE_NUKAGE_SECTOR\n    Wall( fT, vInf, vSS, 2736, -3648, 1376, -3648, 2736-1376, fLt, vSH, TEX_STARTAN3  );\n#else\n\tNull( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1376, -3648 );\n#endif \n    Wall( fT, vInf, vSS, 2240, -2920, 2272, -3008, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2272, -3008, 2432, -3112, 190, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 2432, -3112, 2736, -3112, 304, fLt-kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 2736, -3112, 2736, -3360, 248, fLt+kC, vSH, 0, 136, TEX_STARTAN3, TEX_STARTAN3 );\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1376, -3648, 1376, -3360, 3648-3360, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1376, -3648, 1376, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3392, 1376, -3360, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3520, 1376, -3392, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1472, -2880, 1856, -2880, 1856-1472, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1472, -2880, 1664, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1664, -2880, 1856, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n\t\n\t\/\/ Merge walls\n    Wall( fT, vInf, vSS, 1920, -2920, 2240, -2920, 2240-1920, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1920, -2920, 2176, -2920, 256, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 2176, -2920, 2240, -2920, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector3( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3264, 1344, -3360 );\n    Null( vSS, 1376, -3360, 1376, -3264 );\n    Wall( fT, vInf, vSS, 1344, -3264, 1376, -3264, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1376, -3360, 1344, -3360, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector5( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1344, -3104, 1344, -3200 );\n    Null( vSS, 1376, -3200, 1376, -3104 );\n    Wall( fT, vInf, vSS, 1376, -3200, 1344, -3200, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    Wall( fT, vInf, vSS, 1344, -3104, 1376, -3104, 32, fLt-kC, vSH, TEX_DOORSTOP);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5) );\n}\n\nvoid Sector11( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1528, -3680, 1376, -3648, 155, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1672, -3744, 1528, -3680, 157, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 1984, -3776, 1672, -3744, 313, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 1984, -3648, 1376, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector12( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 64.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2240, -3776, 2208, -3680, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2208, -3680, 2176, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2016, -3680, 1984, -3776, 101, fLt, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 2048, -3680, 2016, -3680, 32, fLt-kC, vSH, TEX_BROWN1);\n    Upper( fT, vInf, vSS, 2176, -3680, 2048, -3680, 128, fLt-kC, vSH, 16, TEX_BROWN1 );\n    Null( vSS, 2240, -3648, 1984, -3648 );\n    Null( vSS, 1984, -3648, 1984, -3776 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid Sector24( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 144.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -2880, 1248, -2528, 353, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1384, -2592, 1344, -2880, 290, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2560, 1384, -2592, 93, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1248, -2528, 1472, -2432, 243, fLt, vSH, TEX_STARTAN3);\n    Upper( fT, vInf, vSS, 1344, -2880, 1216, -2880, 128, fLt-kC, vSH, 72, TEX_STARTAN3 );\n    Upper( fT, vInf, vSS, 1472, -2432, 1472, -2560, 128, fLt+kC, vSH, 88, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector25( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(0.0, 88.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 1472, -2432, 1472, -2560 );\n    Wall( fT, vInf, vSS, 1536, -2432, 1536, -2560, 128, fLt+kC, vSH, TEX_BIGDOOR2);\n    Wall( fT, vInf, vSS, 1536, -2560, 1472, -2560, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1472, -2432, 1536, -2432, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_TLITE6_4) );\n}\n\nvoid Sector27( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.878;\n    const vec2 vSH=vec2(-16.0, 200.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1216, -3392, 1216, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3360, 1184, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3104, 1216, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3104, 1216, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1344, -3264, 1344, -3360, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 1344, -3200, 1344, -3264, 64, fLt+kC, vSH, TEX_STARTAN3);\n    Open( fT, vInf, vSS, 1344, -3104, 1344, -3200, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1344, -3360, 1216, -3392, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1216, -3072, 1344, -3104, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3104, 1184, -3104, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 1184, -3360, 928, -3360, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    Open( fT, vInf, vSS, 928, -3360, 928, -3104, 256, fLt+kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector28( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.753;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 928, -3392, 928, -3360, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3360, 896, -3360, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3360, 1184, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3104, 928, -3104, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3104, 928, -3072, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3072, 1184, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Open( fT, vInf, vSS, 1184, -3392, 928, -3392, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Null( vSS, 928, -3104, 1184, -3104 );\n    Null( vSS, 1184, -3360, 928, -3360 );\n    Null( vSS, 928, -3360, 928, -3104 );\n    Open( fT, vInf, vSS, 896, -3360, 896, -3104, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    Open( fT, vInf, vSS, 928, -3072, 1184, -3072, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) );\n}\n\nvoid Sector29( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1152, -3648, 1088, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1024, -3648, 960, -3648, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1280, -3552, 1152, -3648, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 960, -3648, 832, -3552, 160, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 1344, -3552, 1280, -3552, 64, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -3552, 704, -3552, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 896, -3392, 928, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3360, 896, -3392, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1184, -3392, 1216, -3392, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 896, -3072, 896, -3104, 32, fLt+kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 928, -3072, 896, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1216, -3072, 1184, -3072, 32, fLt-kC, vSH, TEX_BROWN1);\n    Wall( fT, vInf, vSS, 1344, -2880, 1344, -3104, 224, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1184, -3392, 928, -3392 );\n    Null( vSS, 1344, -3360, 1216, -3392 );\n    Null( vSS, 1216, -3072, 1344, -3104 );\n    Wall( fT, vInf, vSS, 704, -2944, 832, -2944, 128, fLt-kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 832, -2944, 968, -2880, 150, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 968, -2880, 1216, -2880, 248, fLt-kC, vSH, TEX_STARTAN3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    Null( vSS, 896, -3360, 896, -3104 );\n    Null( vSS, 928, -3072, 1184, -3072 );\n#ifdef CLOSE_START_SECTOR\t\n    Wall( fT, vInf, vSS, 704, -3552, 704, -2944, 3552-2944, fLt+kC, vSH, TEX_STARTAN3);\n#else\n    Wall( fT, vInf, vSS, 704, -3552, 704, -3360, 192, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 704, -3104, 704, -2944, 160, fLt+kC, vSH, TEX_STARTAN3);\n    Null( vSS, 704, -3104, 704, -3360 );\n#endif\n    Null( vSS, 1344, -2880, 1216, -2880 );\n    Wall( fT, vInf, vSS, 1344, -3360, 1344, -3392, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1344, -3392, 1344, -3552, 3552 - 3392, fLt+kC, vSH, TEX_STARTAN3);\n\t\/\/Wall( fT, vInf, vSS, 1344, -3520, 1344, -3552, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1344, -3392, 1344, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector30( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    float fLt=(hash(floor(iGlobalTime * 10.0)) > 0.3) ? 0.565 : 1.0;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 1088, -3680, 1024, -3680, 64, fLt-kC, vSH, TEX_DOOR3);\n    Wall( fT, vInf, vSS, 1024, -3680, 1024, -3648, 32, fLt+kC, vSH, TEX_LITE3);\n    Wall( fT, vInf, vSS, 1088, -3648, 1088, -3680, 32, fLt+kC, vSH, TEX_LITE3);\n    Null( vSS, 1088, -3648, 1024, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector31( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH );\n    Open( fT, vInf, vSS, 704, -3104, 704, -3360, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 );\n    Wall( fT, vInf, vSS, 512, -3328, 512, -3304, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3160, 512, -3136, 24, fLt+kC, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 512, -3136, 680, -3104, 171, fLt, vSH, TEX_STARTAN3);\n    Wall( fT, vInf, vSS, 680, -3104, 704, -3104, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 704, -3360, 680, -3360, 24, fLt-kC, vSH, TEX_SUPPORT2);\n    Wall( fT, vInf, vSS, 680, -3360, 512, -3328, 171, fLt, vSH, TEX_STARTAN3);\n    Null( vSS, 496, -3160, 496, -3304 );\n    Wall( fT, vInf, vSS, 512, -3304, 496, -3304, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    Wall( fT, vInf, vSS, 496, -3160, 512, -3160, 16, fLt-kC, vSH, TEX_DOORTRAK);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) );\n}\n\nvoid Sector32( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 224.0);\n\n    BeginSector( vSS, vSH );\n    Upper( fT, vInf, vSS, 496, -3160, 496, -3304, 144, fLt+kC, vSH, 120, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 496, -3304, 496, -3328, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3328, 448, -3456, 136, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3456, 128, -3456, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3008, 448, -3008, 320, fLt-kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 496, -3136, 496, -3160, 24, fLt+kC, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 448, -3008, 496, -3136, 136, fLt, vSH, TEX_STARG3);\n    Lower( fT, vInf, vSS, 128, -3264, 160, -3264, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3264, 192, -3264, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3264, 224, -3264, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3264, 256, -3264, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3264, 288, -3264, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3264, 320, -3264, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 320, -3264, 320, -3200, 64, fLt+kC, vSH, 8, TEX_STEP6 );\n    Lower( fT, vInf, vSS, 320, -3200, 288, -3200, 32, fLt-kC, vSH, 8, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 288, -3200, 256, -3200, 32, fLt-kC, vSH, 24, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 256, -3200, 224, -3200, 32, fLt-kC, vSH, 40, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 224, -3200, 192, -3200, 32, fLt-kC, vSH, 56, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 192, -3200, 160, -3200, 32, fLt-kC, vSH, 72, TEX_SLADWALL );\n    Lower( fT, vInf, vSS, 160, -3200, 128, -3200, 32, fLt-kC, vSH, 88, TEX_SLADWALL );\n    Open( fT, vInf, vSS, 128, -3200, 64, -3072, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Wall( fT, vInf, vSS, 64, -3072, 128, -3008, 90, fLt, vSH, TEX_STARG3);\n    Wall( fT, vInf, vSS, 128, -3456, 64, -3392, 90, fLt, vSH, TEX_STARG3);\n    Open( fT, vInf, vSS, 64, -3392, 128, -3264, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 );\n    Open( fT, vInf, vSS, 256, -3136, 320, -3136, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3136, 320, -3072, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3072, 256, -3072, 64, fLt-kC, vSH, 40, 184, TEX_SW1COMP, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3072, 256, -3136, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3392, 320, -3392, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3392, 320, -3328, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 320, -3328, 256, -3328, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    Open( fT, vInf, vSS, 256, -3328, 256, -3392, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_FLOOR7_2) );\n}\n\nvoid Sector35( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3392, 320, -3392 );\n    Null( vSS, 320, -3392, 320, -3328 );\n    Null( vSS, 320, -3328, 256, -3328 );\n    Null( vSS, 256, -3328, 256, -3392 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector36( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH );\n    Null( vSS, 256, -3136, 320, -3136 );\n    Null( vSS, 320, -3136, 320, -3072 );\n    Null( vSS, 320, -3072, 256, -3072 );\n    Null( vSS, 256, -3072, 256, -3136 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1) );\n}\n\nvoid Sector63( inout float fT, inout vec4 vInf )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH );\n    Wall( fT, vInf, vSS, 2736, -3648, 2488, -3744, 265, fLt, vSH, TEX_BROWN144);\n    Wall( fT, vInf, vSS, 2488, -3744, 2240, -3776, 250, fLt, vSH, TEX_BROWN144);\n    Null( vSS, 2736, -3648, 2240, -3648 );\n    Null( vSS, 2240, -3776, 2240, -3648 );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1) );\n}\n\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo )\n{\n    vHitInfo = vec4(0.0);\n    fClosestT = 10000.0;\n\n#ifdef ENABLE_NUKAGE_SECTORS\n    Sector0( fClosestT, vHitInfo );\n    Sector1( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector3( fClosestT, vHitInfo );\n    Sector5( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector11( fClosestT, vHitInfo );\n    Sector12( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector24( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\t\n    Sector25( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_START_SECTORS\n\tSector27( fClosestT, vHitInfo );\n    Sector28( fClosestT, vHitInfo );\n    Sector29( fClosestT, vHitInfo );\n    Sector30( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_SECTOR_31\n    Sector31( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_MISC_SECTORS\n    Sector32( fClosestT, vHitInfo );\n    Sector35( fClosestT, vHitInfo );\n    Sector36( fClosestT, vHitInfo );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector63( fClosestT, vHitInfo );\n#endif\n}\n\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ End of generated code\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = hash( fl );\n\tfloat h1 = hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(30.0, 30.0, 30.0), vec3(150.0, 150.0, 150.0), fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexFlat14( vec2 vTexCoord, float fRandom )\n{\n\treturn mix( vec3(0.0, 0.0, 35.0 \/ 255.0), vec3(0.0, 0.0, 200.0 \/ 255.0), fRandom * fRandom);\n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(0.6);\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) \/ 255.0, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) * 1.1 \/ 255.0, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(119.0, 95.0, 63.0), vec3(147.0, 123.0, 99.0), fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vec3(0.3, 0.2, 0.1), fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\n#ifdef ENABLE_SPRITES\n\nvec3 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n\treturn col;\n}\n\nvec3 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n\treturn col;\n}\n\n#endif \n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec3 col = vec3(1.0, 0.0, 1.0);\n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iGlobalTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n\t\n\t     if(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\telse if(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    else if(fTexture == TEX_FLOOR7_1) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    else if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    else if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    else if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    else if(fTexture == TEX_FLAT14) { fPersistence = 2.0; }\n    else if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    else if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    else if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n\telse if(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n    else if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    else if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    else if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    else if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    else if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(23.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(57.0, 22.0); fPersistence = 1.0; }\n#endif\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(32.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(64.0, 32.0); }\t\n#endif\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq) - ((vTexCoord.y) \/ vSize.y);\n    \n\t     if(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\telse if(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom );\n    else if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\telse if(fTexture == TEX_FLAT14) \tcol = TexFlat14( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    else if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom );\n    else if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    else if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    else if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\telse if(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom );\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) \t\tcol = TexBar1A( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_PLAYW) \t\tcol = TexPlayW( vTexCoord, fRandom, fHRandom );\t\n#endif\n\t\n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col);\n    #endif\n\n    return col;\n}\n","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define N(T,N) t+=float(T); if(x>t) r=vec2(N,t);\n#define L(T,N,X) t+=float(T); if((x>t) && (x<(t+float(X)))) r=vec2(N,t);\n\nvec2 GetTrack1Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(1628,40,8)N(24,40)N(28,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(28,40)N(24,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(28,48)L(24,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(28,40,8)N(24,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(28,47)N(24,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)L(24,63,14)L(14,60,14)L(14,59,12)L(12,63,12)L(12,66,12)L(12,64,14)L(14,63,12)L(12,59,14)L(14,63,12)L(12,64,12)L(12,66,12)L(12,67,14)L(14,66,14)L(14,64,12)L(12,63,12)L(12,59,12)L(12,40,8)N(26,40)N(26,52)L(24,40,8)N(28,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(28,48)L(24,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(28,40)N(24,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(28,50)L(24,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(28,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,67,14)L(14,64,12)L(12,59,12)L(12,64,12)L(12,67,14)L(14,64,14)L(14,67,12)L(12,71,12)L(12,67,12)L(12,64,14)\n    return r;\n}\n\nvec2 GetTrack2Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(0,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(26,40)N(26,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(26,48)L(26,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(26,40,10)N(26,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(26,47)N(26,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(26,46)L(126,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(26,48)L(26,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(26,40)N(26,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(26,40,10)N(26,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,66,14)L(14,64,12)L(12,63,12)L(12,66,12)L(12,69,14)L(14,67,12)L(12,66,14)L(14,63,12)L(12,66,12)L(12,67,14)L(14,69,12)L(12,71,14)L(14,69,12)L(12,67,12)L(12,66,12)L(12,63,14)L(14,40,6)N(26,40)N(24,52)L(26,40,8)N(26,40)N(24,50)L(26,40,10)N(26,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,10)N(24,40)N(26,47)N(26,48)L(24,40,6)N(26,40)N(26,52)L(26,40,8)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(24,46)L(128,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,12)N(26,40)N(26,48)L(26,40,8)N(26,40)N(24,46)L(26,40,8)N(26,40)N(24,47)N(26,48)L(26,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)L(26,40,14)L(26,71,12)L(12,67,12)L(12,64,14)L(14,67,12)L(12,71,14)L(14,67,12)L(12,71,12)L(12,76,12)L(12,71,14)L(14,67,12)\n    return r;\n}\n\nvec2 GetTrack3Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)N(408,40)N(406,40)N(408,40)N(406,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)\n    return r;\n}\n\nvec2 GetTrack4ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,36)N(406,36)N(406,36)N(408,36)N(408,36)L(38,49,8)N(370,36)L(36,49,10)N(370,36)L(38,49,8)N(370,36)L(38,49,8)L(164,36,12)L(28,36,10)L(24,36,12)L(26,36,14)L(26,36,10)L(24,36,12)L(26,36,10)L(26,36,12)N(24,36)N(2,46)N(50,40)N(2,46)L(50,36,12)N(2,46)N(22,36)N(26,40)N(2,46)N(48,36)N(2,46)N(50,40)N(4,46)L(46,36,14)N(2,46)N(24,36)N(24,40)N(4,46)N(48,36)N(2,46)N(50,40)N(2,46)L(48,36,14)N(6,46)N(20,36)N(24,40)N(4,46)N(48,36)N(52,40)N(48,46)L(2,36,14)N(26,36)N(24,40)N(2,46)N(48,46)N(2,36)N(50,46)N(50,46)L(28,36,14)N(24,46)N(52,36)N(50,40)N(2,46)N(48,36)N(52,40)N(2,46)N(50,36)N(48,46)N(2,40)N(50,46)N(26,36)N(26,40)L(50,36,6)L(2,50,8)L(24,36,8)L(24,36,8)L(4,40,6)L(24,36,8)L(24,36,8)L(4,45,8)L(2,40,6)\n    return r;\n}\n\nvec2 GetTrack4BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)L(38,57,8)N(370,40)L(36,57,10)N(370,40)L(38,57,8)N(370,40)L(38,57,8)L(164,40,12)L(28,40,8)L(24,40,14)L(26,40,12)L(26,40,12)L(24,40,12)L(26,40,14)L(26,40,12)N(636,46)N(52,46)N(202,40)N(50,36)N(52,40)N(52,46)N(100,46)N(104,46)L(100,36,14)N(52,46)L(52,40,8)L(52,47,8)\n    return r;\n}\n\nvec2 GetTrack4CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,41)N(406,41)N(406,41)N(408,41)N(408,41)N(408,41)N(406,41)N(408,41)L(202,41,12)L(28,41,8)L(24,41,12)L(26,41,10)L(26,41,12)L(24,41,12)L(26,41,12)L(26,41,12)\n    return r;\n}\n\nvec2 GetTrack4DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,49)N(408,49)N(406,49)N(408,49)\n    return r;\n}\n\nvec2 GetTrack4ENote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,57)N(408,57)L(406,57,14)L(408,57,14)\n    return r;\n}\n\n\n\/\/ ------------------- 8< ------------------- 8< ------------------- 8< -------------------\n\n#define PI radians(180.0)\n#define TWO_PI radians(360.0)\n\nfloat NoteToHz(float n)\n{  \t\n\treturn 440.0*pow( 2.0, (n-69.0)\/12.0 );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nvec4 Saw4( vec4 x )\n{\n\treturn fract( x ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nvec4 Cos4( vec4 x )\n{\n\tx = abs(fract(x) * 2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn x2 * 6.0 - x2*x * 4.0  - 1.0;\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\n\/\/ Thanks to Dave_Hoskins for the hash\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\nfloat StepNoise( float t, float freq )\n{\n\tfloat noiset = t * freq;\n\tfloat tfloor = floor(noiset);\n\t\n\tfloat n = Hash(tfloor);\n\treturn n * 2.0 - 1.0;\n}\n\nfloat Cos4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Cos4((x+phase) * freq), amp);\n}\n\nfloat Saw4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Saw4((x+phase) * freq), amp);\n}\n\n\nfloat Test( float t )\n{\n\treturn Saw4(t, vec4(0.0, 0.5, 0.1, 0.4), vec4(1.0, 1.50, 2.00, -3.00), vec4(1.0, 0.5, 0.25, 0.125));\n}\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\nfloat Test2(float f)\n{\n    return Test(f) + Test(f - 0.0454) * 0.4 + Test(f - 0.1123) * 0.3 + Test(f - 0.1523) * 0.1;\n}\nfloat Instrument( const in vec2 vFreqTime )\n{\n    return Test2( vFreqTime.x * vFreqTime.y ) * Envelope( vFreqTime.y, 0.01, 1.0 );    \n}\n\nfloat Track1Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime * vec2(2.0, 1.0) ) * 0.75;\n}\n\nfloat Track2Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime );\n}\n\nfloat Track3Basic(float x)\n{\n    return FBM(x, 0.5);\n}\n\nfloat Track3Instrument( const in vec2 vFreqTime )\n{\n    return Track3Basic(vFreqTime.y * vFreqTime.x) * Envelope(vFreqTime.y, 0.4) * 2.0;\n}\n\nfloat kick(float freq, float fNoteTime){\n    float a = clamp(1.0-fNoteTime,0.0,1.0);\n    float osc = sin(pow(a,5.0)*freq);\n    return osc * pow(a, 2.0);\n}\n\nfloat Track4Instrument( const in vec2 vFreqTime )\n{\n    return FBM(vFreqTime.y * vFreqTime.x * 8.0, 2.0) * Envelope(vFreqTime.y, 0.5);\n}\n\n\nconst float kMidiTimebase = 200.0;\nconst float kInvMidiTimebase = 1.0 \/ kMidiTimebase;\n\nvec2 GetNoteData( const in vec2 vMidiResult, const in float fMidiTime )\n{\n    return vec2( NoteToHz(vMidiResult.x), abs(fMidiTime - vMidiResult.y) * kInvMidiTimebase );\n}\n\nfloat PlayMidi( const in float time )\n{\n    if(time < 0.0)\n\t\treturn 0.0;\n    \n    float fMidiTime = time * kMidiTimebase;\n    \n    float fResult = 0.0;\n    \n    fResult += Track1Instrument( GetNoteData( GetTrack1Note(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2Note(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3Note(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4BNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4CNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4DNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ENote(fMidiTime), fMidiTime ) );\n    \n    fResult = clamp(fResult * 0.1, -1.0, 1.0);\n    \n    float fFadeEnd = 20.0 * 240.0 \/ kMidiTimebase;\n    float fFadeTime = 5.0;\n    float fFade = (time - (fFadeEnd - fFadeTime)) \/ fFadeTime;    \n    fResult *= clamp(1.0 - fFade, 0.0, 1.0);\n    \n    return fResult;\n}\n\nvec2 mainSound(float time)\n{\n    return vec2( PlayMidi(time - 3.0) );\n}\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( iGlobalTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tfragColor = vec4((vResult),1.0);\n}\n#endif\n\n","name":"","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"MdlGW7","date":"1372661086","viewed":32136,"name":"Cloudy Terrain","username":"iq","description":"A terrain full of trees or something (up to your interpretation). Distance field raymarching for the terrain. Linearly volumetric raymarching for the foliage. Linearly volumetric raymarching for clouds. Plain plane Raytraced for lakes.","likes":159,"published":3,"flags":0,"tags":["procedural","3d","raymarching","distancefield","clouds","volumetric"],"hasliked":0},"renderpass":[{"inputs":[{"id":8,"src":"\/presets\/tex07.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = texture2D( iChannel0, x.xy\/256.0 + (p.z+0.0)*120.7123 ).x;\n    float b = texture2D( iChannel0, x.xy\/256.0 + (p.z+1.0)*120.7123 ).x;\n\treturn mix( a, b, f.z );\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, texture2D( iChannel0, 0.001*p.zx,-100.0).x );\n\treturn 0.1 + isLake*0.9*texture2D( iChannel1, 0.01*p.xz ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = texture2D( iChannel0, 0.001*pos.zx,-100.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h\/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, texture2D(iChannel0, pos.xz*0.15, -100.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)\/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = texture2D( iChannel0, pos.xz,-100.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*texture2D( iChannel1, 0.1*pos.xz ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\nfloat kk = 0.0;\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.0;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t\/\/kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\tkk += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;\/\/max(0.1,0.05*t);\n\t}\nkk = clamp( kk, 0.0, 1.0 );\n\tsum.xyz \/= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat time = 23.5+iGlobalTime;\n\t\n    \/\/ camera\t\n\tvec3 ro = path( time );\n\tvec3 ta = path( time+1.0 );\n\tta.y *= 0.2;\n\tfloat roll = 0.3*cos(0.07*time);\n\t\/\/ camera tx\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray direction\n    vec3 rd = normalize( cam * vec3(p.xy,1.75) );\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    \/\/ lakes\n    float gt = (0.0-ro.y)\/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture2D( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture2D( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture2D( iChannel3, 6.0*pos.xz ).xz);\n\t\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture2D( iChannel0, 0.001*pos.zx,-100.0).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        \/\/ trees\t\t\n        vec4 res = raymarchTrees( ro, rd, t, bcol );\n\t    col = mix( col, res.xyz, res.w );\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    \/\/ clouds\t\n\t{\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t );\n\tcol = mix( col, res.xyz, res.w );\n\t}\n\n\t\/\/col += 0.2*vec3(1.0,0.8,0.7)*(kk);\n\t\/\/col = vec3(smoothstep(0.3,0.4,kk));\n\tcol += (1.0-0.8*col)*kk*kk*kk*0.3*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdsGDB","date":"1378762363","viewed":30644,"name":"Buoy","username":"TekF","description":"A ray-traced sphere floating in a ray-marched ocean. Refraction & reflection effects.<br\/>It looks particularly nice when you pause it and move the camera.","likes":153,"published":3,"flags":0,"tags":["raytracing","raymarching","noise","reflection","refraction"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"}],"code":"\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\nconst float tau = 6.28318530717958647692;\r\n\r\n\/\/ Gamma correction\r\n#define GAMMA (2.2)\r\n\r\nvec3 ToLinear( in vec3 col )\r\n{\r\n\t\/\/ simulate a monitor, converting colour values into light values\r\n\treturn pow( col, vec3(GAMMA) );\r\n}\r\n\r\nvec3 ToGamma( in vec3 col )\r\n{\r\n\t\/\/ convert back into colour values, so the correct light will come out of the monitor\r\n\treturn pow( col, vec3(1.0\/GAMMA) );\r\n}\r\n\r\nvec3 localRay;\r\n\r\n\/\/ Set up a camera looking at the scene.\r\n\/\/ origin - camera is positioned relative to, and looking at, this point\r\n\/\/ distance - how far camera is from origin\r\n\/\/ rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\r\n\/\/ zoom - the relative length of the lens\r\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord )\r\n{\r\n\t\/\/ get rotation coefficients\r\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\r\n\tvec4 s;\r\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); \/\/ worth testing if this is faster as sin or sqrt(1.0-cos);\r\n\ts.zw = -s.xy;\r\n\r\n\t\/\/ ray in view space\r\n\tray.xy = fragCoord.xy - iResolution.xy*.5;\r\n\tray.z = iResolution.y*zoom;\r\n\tray = normalize(ray);\r\n\tlocalRay = ray;\r\n\t\r\n\t\/\/ rotate ray\r\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\r\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\r\n\t\r\n\t\/\/ position camera\r\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\r\n}\r\n\r\n\r\n\/\/ Noise functions, distinguished by variable types\r\n\r\nvec2 Noise( in vec3 x )\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\r\n\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\r\n\r\n\/\/ hardware interpolation lacks precision\r\n\/\/\tvec4 rg = texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\r\n\tvec4 rg = mix( mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(1,0)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\t  mix(\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+vec2(0,1)+0.5)\/256.0, -100.0 ),\r\n\t\t\t\ttexture2D( iChannel0, (floor(uv)+1.5)\/256.0, -100.0 ),\r\n\t\t\t\tfract(uv.x) ),\r\n\t\t\t\tfract(uv.y) );\r\n\t\t\t\t  \r\n\r\n\treturn mix( rg.yw, rg.xz, f.z );\r\n}\r\n\r\nvec4 Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x.xy);\r\n    vec2 f = fract(x.xy);\r\n\tf = f*f*(3.0-2.0*f);\r\n\/\/\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\r\n\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 );\r\n}\r\n\r\nvec4 Noise( in ivec2 x )\r\n{\r\n\treturn texture2D( iChannel0, (vec2(x)+0.5)\/256.0, -100.0 );\r\n}\r\n\r\nvec2 Noise( in ivec3 x )\r\n{\r\n\tvec2 uv = vec2(x.xy)+vec2(37.0,17.0)*float(x.z);\r\n\treturn texture2D( iChannel0, (uv+0.5)\/256.0, -100.0 ).xz;\r\n}\r\n\r\n\r\nfloat Waves( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 6;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WavesDetail( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 8;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WavesSmooth( vec3 pos )\r\n{\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves = 2;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\t\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tfor ( int i=0; i < octaves; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\t\/\/f  = f*2.0+abs(Noise(pos).x-.5)*2.0;\r\n\t\tf  = f*2.0+sqrt(pow(Noise(pos).x-.5,2.0)+.01)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= exp2(float(octaves));\r\n\t\r\n\treturn (.5-f)*1.0;\r\n}\r\n\r\nfloat WaveCrests( vec3 ipos, in vec2 fragCoord )\r\n{\r\n\tvec3 pos = ipos;\r\n\tpos *= .2*vec3(1,1,1);\r\n\t\r\n\tconst int octaves1 = 6;\r\n\tconst int octaves2 = 16;\r\n\tfloat f = 0.0;\r\n\r\n\t\/\/ need to do the octaves from large to small, otherwise things don't line up\r\n\t\/\/ (because I rotate by 45 degrees on each octave)\r\n\tpos += iGlobalTime*vec3(0,.1,.1);\r\n\tvec3 pos2 = pos;\r\n\tfor ( int i=0; i < octaves1; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*1.5+abs(Noise(pos).x-.5)*2.0;\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tpos = pos2 * exp2(float(octaves1));\r\n\tpos.y = -.05*iGlobalTime;\r\n\tfor ( int i=octaves1; i < octaves2; i++ )\r\n\t{\r\n\t\tpos = (pos.yzx + pos.zyx*vec3(1,-1,1))\/sqrt(2.0);\r\n\t\tf  = f*1.5+pow(abs(Noise(pos).x-.5)*2.0,1.0);\r\n\t\tpos *= 2.0;\r\n\t}\r\n\tf \/= 1500.0;\r\n\t\r\n\tf -= Noise(ivec2(fragCoord.xy)).x*.01;\r\n\t\r\n\treturn pow(smoothstep(.4,-.1,f),6.0);\r\n}\r\n\r\n\r\nvec3 Sky( vec3 ray )\r\n{\r\n\treturn vec3(.4,.45,.5);\r\n}\r\n\r\n\r\nvec3 boatRight, boatUp, boatForward;\r\nvec3 boatPosition;\r\n\r\nvoid ComputeBoatTransform( void )\r\n{\r\n\tvec3 samples[5];\r\n\t\r\n\tsamples[0] = vec3(0,0, 0);\r\n\tsamples[1] = vec3(0,0, .5);\r\n\tsamples[2] = vec3(0,0,-.5);\r\n\tsamples[3] = vec3( .5,0,0);\r\n\tsamples[4] = vec3(-.5,0,0);\r\n\t\r\n\tsamples[0].y = WavesSmooth(samples[0]);\r\n\tsamples[1].y = WavesSmooth(samples[1]);\r\n\tsamples[2].y = WavesSmooth(samples[2]);\r\n\tsamples[3].y = WavesSmooth(samples[3]);\r\n\tsamples[4].y = WavesSmooth(samples[4]);\r\n\r\n\tboatPosition = (samples[0]+samples[1]+samples[2]+samples[3]+samples[4])\/5.0;\r\n\t\r\n\tboatRight = samples[3]-samples[4];\r\n\tboatForward = samples[1]-samples[2];\r\n\tboatUp = normalize(cross(boatForward,boatRight));\r\n\tboatRight = normalize(cross(boatUp,boatForward));\r\n\tboatForward = normalize(boatForward);\r\n\t\r\n\tboatPosition += .0*boatUp;\r\n}\r\n\r\nvec3 BoatToWorld( vec3 dir )\r\n{\r\n\treturn dir.x*boatRight+dir.x*boatUp+dir.x*boatForward;\r\n}\r\n\r\nvec3 WorldToBoat( vec3 dir )\r\n{\r\n\treturn vec3( dot(dir,boatRight), dot(dir,boatUp), dot(dir,boatForward) );\r\n}\r\n\r\nfloat TraceBoat( vec3 pos, vec3 ray )\r\n{\r\n\tvec3 c = boatPosition;\r\n\tfloat r = 1.0;\r\n\t\r\n\tc -= pos;\r\n\t\r\n\tfloat t = dot(c,ray);\r\n\t\r\n\tfloat p = length(c-t*ray);\r\n\tif ( p > r )\r\n\t\treturn 0.0;\r\n\t\r\n\treturn t-sqrt(r*r-p*p);\r\n}\r\n\r\n\r\nvec3 ShadeBoat( vec3 pos, vec3 ray )\r\n{\r\n\tpos -= boatPosition;\r\n\tvec3 norm = normalize(pos);\r\n\tpos = WorldToBoat(pos);\r\n\t\r\n\tvec3 lightDir = normalize(vec3(-2,3,1));\r\n\tfloat ndotl = dot(norm,lightDir);\r\n\t\r\n\t\/\/ allow some light bleed, as if it's subsurface scattering through plastic\r\n\tvec3 light = smoothstep(-.1,1.0,ndotl)*vec3(1.0,.9,.8)+vec3(.06,.1,.1);\r\n\r\n\t\/\/ anti-alias the albedo\r\n\tfloat aa = 4.0\/iResolution.x;\r\n\t\r\n\t\/\/vec3 albedo = ((fract(pos.x)-.5)*(fract(pos.y)-.5)*(fract(pos.z)-.5) < 0.0) ? vec3(0) : vec3(1);\r\n\tvec3 albedo = vec3(1,.01,0);\r\n\talbedo = mix( vec3(.04), albedo, smoothstep( .25-aa, .25, abs(pos.y) ) );\r\n\talbedo = mix( mix( vec3(1), vec3(.04), smoothstep(-aa*4.0,aa*4.0,cos(atan(pos.x,pos.z)*6.0)) ), albedo, smoothstep( .2-aa*1.5, .2, abs(pos.y) ) );\r\n\talbedo = mix( vec3(.04), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.6) ) );\r\n\talbedo = mix( vec3(1,.8,.08), albedo, smoothstep( .05-aa*1.0, .05, abs(abs(pos.y)-.65) ) );\r\n\t\r\n\tvec3 col = albedo*light;\r\n\t\r\n\t\/\/ specular\r\n\tvec3 h = normalize(lightDir-ray);\r\n\tfloat s = pow(max(0.0,dot(norm,h)),100.0)*100.0\/32.0;\r\n\t\r\n\tvec3 specular = s*vec3(1,1,1);\r\n\r\n\tvec3 rr = reflect(ray,norm);\r\n\tspecular += mix( vec3(0,.04,.04), Sky(rr), smoothstep( -.1, .1, rr.y ) );\r\n\t\r\n\tfloat ndotr = dot(norm,ray);\r\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\r\n\tfresnel = mix( .001, 1.0, fresnel );\r\n\r\n\tcol = mix( col, specular, fresnel );\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\nfloat OceanDistanceField( vec3 pos )\r\n{\r\n\treturn pos.y - Waves(pos);\r\n}\r\n\r\nfloat OceanDistanceFieldDetail( vec3 pos )\r\n{\r\n\treturn pos.y - WavesDetail(pos);\r\n}\r\n\r\nvec3 OceanNormal( vec3 pos )\r\n{\r\n\tvec3 norm;\r\n\tvec2 d = vec2(.01*length(pos),0);\r\n\t\r\n\tnorm.x = OceanDistanceFieldDetail( pos+d.xyy )-OceanDistanceFieldDetail( pos-d.xyy );\r\n\tnorm.y = OceanDistanceFieldDetail( pos+d.yxy )-OceanDistanceFieldDetail( pos-d.yxy );\r\n\tnorm.z = OceanDistanceFieldDetail( pos+d.yyx )-OceanDistanceFieldDetail( pos-d.yyx );\r\n\r\n\treturn normalize(norm);\r\n}\r\n\r\nfloat TraceOcean( vec3 pos, vec3 ray )\r\n{\r\n\tfloat h = 1.0;\r\n\tfloat t = 0.0;\r\n\tfor ( int i=0; i < 100; i++ )\r\n\t{\r\n\t\tif ( h < .01 || t > 100.0 )\r\n\t\t\tbreak;\r\n\t\th = OceanDistanceField( pos+t*ray );\r\n\t\tt += h;\r\n\t}\r\n\t\r\n\tif ( h > .1 )\r\n\t\treturn 0.0;\r\n\t\r\n\treturn t;\r\n}\r\n\r\n\r\nvec3 ShadeOcean( vec3 pos, vec3 ray, in vec2 fragCoord )\r\n{\r\n\tvec3 norm = OceanNormal(pos);\r\n\tfloat ndotr = dot(ray,norm);\r\n\r\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0);\r\n\t\r\n\tvec3 reflectedRay = ray-2.0*norm*ndotr;\r\n\tvec3 refractedRay = ray+(-cos(1.33*acos(-ndotr))-ndotr)*norm;\t\r\n\trefractedRay = normalize(refractedRay);\r\n\r\n\tconst float crackFudge = .0;\r\n\t\r\n\t\/\/ reflection\r\n\tvec3 reflection = Sky(reflectedRay);\r\n\tfloat t=TraceBoat( pos-crackFudge*reflectedRay, reflectedRay );\r\n\t\r\n\tif ( t > 0.0 )\r\n\t{\r\n\t\treflection = ShadeBoat( pos+(t-crackFudge)*reflectedRay, reflectedRay );\r\n\t}\r\n\r\n\t\r\n\t\/\/ refraction\r\n\tt=TraceBoat( pos-crackFudge*refractedRay, refractedRay );\r\n\t\r\n\tvec3 col = vec3(0,.04,.04); \/\/ under-sea colour\r\n\tif ( t > 0.0 )\r\n\t{\r\n\t\tcol = mix( col, ShadeBoat( pos+(t-crackFudge)*refractedRay, refractedRay ), exp(-t) );\r\n\t}\r\n\t\r\n\tcol = mix( col, reflection, fresnel );\r\n\t\r\n\t\/\/ foam\r\n\tcol = mix( col, vec3(1), WaveCrests(pos,fragCoord) );\r\n\t\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tComputeBoatTransform();\r\n\t\r\n\tvec2 camRot = vec2(.5,.5)+vec2(-.35,4.5)*(iMouse.yx\/iResolution.yx);\r\n\tvec3 pos, ray;\r\n\tCamPolar( pos, ray, vec3(0), camRot, 3.0, 1.0, fragCoord );\r\n\t\r\n\tfloat to = TraceOcean( pos, ray );\r\n\tfloat tb = TraceBoat( pos, ray );\r\n\t\r\n\tvec3 result;\r\n\tif ( to > 0.0 && ( to < tb || tb == 0.0 ) )\r\n\t\tresult = ShadeOcean( pos+ray*to, ray, fragCoord );\r\n\telse if ( tb > 0.0 )\r\n\t\tresult = ShadeBoat( pos+ray*tb, ray );\r\n\telse\r\n\t\tresult = Sky( ray );\r\n\t\r\n\t\/\/ vignette effect\r\n\tresult *= 1.1*smoothstep( .35, 1.0, localRay.z );\r\n\t\r\n\tfragColor = vec4(ToGamma(result),1.0);\r\n}\r\n","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Msl3Rr","date":"1362385890","viewed":28218,"name":"Cubescape","username":"iq","description":"Raymarched rounded pulsating cubes","likes":168,"published":3,"flags":1,"tags":["procedural","3d","raymarching","sound","reactive","music","vr"],"hasliked":0},"renderpass":[{"inputs":[{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":18,"src":"\/presets\/mzk01.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/---------------------------------\n\n\/\/#define ANTIALIAS\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\n\nfloat maxcomp( in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\nfloat dbox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture2D( sam, p.yz );\n\tvec4 y = texture2D( sam, p.zx );\n\tvec4 z = texture2D( sam, p.yx );\n    vec3 a = abs(n);\n\treturn (x*a.x + y*a.y + z*a.z) \/ (a.x + a.y + a.z);\n}\n\n\/\/---------------------------------\n\nfloat freqs[4];\n\nvec3 mapH( in vec2 pos )\n{\n\tvec2 fpos = fract( pos ); \n\tvec2 ipos = floor( pos );\n\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\tf += freqs[0] * clamp(1.0 - abs(id-0.20)\/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)\/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)\/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)\/0.30, 0.0, 1.0 );\n\n    f = pow( clamp( f, 0.0, 1.0 ), 2.0 );\n    float h = 2.5*f;\n\n    return vec3( h, id, f );\n}\n\nvec3 map( in vec3 pos )\n{\n\tvec2  p = fract( pos.xz ); \n    vec3  m = mapH( pos.xz );\n\tfloat d = dbox( vec3(p.x-0.5,pos.y-0.5*m.x,p.y-0.5), vec3(0.3,m.x*0.5,0.3), 0.1 );\n    return vec3( d, m.yz );\n}\n\nconst float surface = 0.001;\n\n#if 0\nvec3 trace( in vec3 ro, in vec3 rd, in float startf, in float maxd )\n{ \n    float s = surface*2.0;\n    float t = startf;\n\n    float sid = -1.0;\n\tfloat alt = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( s<surface || t>maxd ) break;\n        t += 0.15*s;\n\t    vec3 res = map( ro + rd*t );\n        s   = res.x;\n\t    sid = res.y;\n\t\talt = res.z;\n    }\n    if( t>maxd ) sid = -1.0;\n    return vec3( t, sid, alt );\n}\n\n#else\n\nvec3 trace( vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    ro += tmin*rd;\n    \n\tvec2 pos = floor(ro.xz);\n    vec3 rdi = 1.0\/rd;\n    vec3 rda = abs(rdi);\n\tvec2 rds = sign(rd.xz);\n\tvec2 dis = (pos-ro.xz+ 0.5 + rds*0.5) * rdi.xz;\n\t\n\tvec3 res = vec3( -1.0 );\n\n    \/\/ traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<28; i++ ) \n\t{\n        vec3 cub = mapH( pos );\n\n        #if 1\n            vec2 pr = pos+0.5-ro.xz;\n\t\t\tvec2 mini = (pr-0.5*rds)*rdi.xz;\n\t        float s = max( mini.x, mini.y );\n            if( (tmin+s)>tmax ) break;\n        #endif\n        \n        \n        \/\/ intersect box\n\t\tvec3  ce = vec3( pos.x+0.5, 0.5*cub.x, pos.y+0.5 );\n        vec3  rb = vec3(0.3,cub.x*0.5,0.3);\n        vec3  ra = rb + 0.12;\n\t\tvec3  rc = ro - ce;\n        float tN = maxcomp( -rdi*rc - rda*ra );\n        float tF = maxcomp( -rdi*rc + rda*ra );\n        if( tN < tF )\/\/&& tF > 0.0 )\n        {\n            \/\/ raymarch\n            float s = tN;\n            float h = 1.0;\n            for( int j=0; j<24; j++ )\n            {\n                h = dbox( rc+s*rd, rb, 0.1 ); \n                s += h;\n                if( s>tF ) break;\n            }\n\n            if( h < (surface*s*2.0) )\n            {\n                res = vec3( s, cub.yz );\n                break; \n            }\n            \n\t\t}\n\n        \n        \/\/ step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*rda.xz;\n        pos += mm*rds;\n\t}\n\n    res.x += tmin;\n    \n\treturn res;\n}\n#endif\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*surface*t;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nconst vec3 light1 = vec3(  0.70, 0.52, -0.45 );\nconst vec3 light2 = vec3( -0.71, 0.000,  0.71 );\nconst vec3 lpos = vec3(0.0) + 6.0*light1;\n\nvec2 boundingVlume( vec2 tminmax, in vec3 ro, in vec3 rd )\n{\n    float bp = 2.7;\n    float tp = (bp-ro.y)\/rd.y;\n    if( tp>0.0 ) \n    {\n        if( ro.y>bp ) tminmax.x = max( tminmax.x, tp );\n        else          tminmax.y = min( tminmax.y, tp );\n    }\n    bp = 0.0;\n    tp = (bp-ro.y)\/rd.y;\n    if( tp>0.0 ) \n    {\n        if( ro.y>bp ) tminmax.y = min( tminmax.y, tp );\n    }\n    return tminmax;\n}\n\n\nvec3 doLighting( in vec3 col, in float ks,\n                 in vec3 pos, in vec3 nor, in vec3 rd )\n{\n    vec3  ldif = pos - lpos;\n    float llen = length( ldif );\n    ldif \/= llen;\n\tfloat con = dot(-light1,ldif);\n\tfloat occ = mix( clamp( pos.y\/4.0, 0.0, 1.0 ), 1.0, max(0.0,nor.y) );\n    vec2 sminmax = vec2(0.01, 5.0);\n    \/\/sminmax = boundingVlume( sminmax, pos, -ldif );\n    float sha = softshadow( pos, -ldif, sminmax.x, sminmax.y, 32.0 );;\n\t\t\n    float bb = smoothstep( 0.5, 0.8, con );\n    float lkey = clamp( dot(nor,-ldif), 0.0, 1.0 );\n\tvec3  lkat = vec3(1.0);\n          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;\n          lkat \/= 1.0+0.25*llen*llen;\t\t\n\t\t  lkat *= 25.0;\n          lkat *= sha;\n    float lbac = clamp( 0.1 + 0.9*dot( light2, nor ), 0.0, 1.0 );\n          lbac *= smoothstep( 0.0, 0.8, con );\n\t\t  lbac \/= 1.0+0.2*llen*llen;\t\t\n\t\t  lbac *= 4.0;\n\tfloat lamb = 1.0 - 0.5*nor.y;\n          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );\n\t\t  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );\n\t\t  lamb *= 0.25;\n\t\t\n    vec3 lin  = 1.0*vec3(0.20,0.05,0.02)*lamb*occ;\n         lin += 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);\n         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ;\n         lin *= vec3(1.3,1.1,1.0);\n\n    col = col*lin;\n\n    vec3 spe = vec3(1.0)*occ*lkat*pow( clamp(dot( reflect(rd,nor), -ldif  ),0.0,1.0), 4.0 );\n\tcol += (0.5+0.5*ks)*0.5*spe*vec3(1.0,0.9,0.7);\n\n    return col;\n}\n\nmat3 setLookAt( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3( 0.0 );\n\n    vec2 tminmax = vec2(0.0, 40.0 );\n\n    tminmax = boundingVlume( tminmax, ro, rd );\n\n    \/\/ raytrace\n    vec3 res = trace( ro, rd, tminmax.x, tminmax.y );\n    if( res.y > -0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        \/\/ material\t\n        col = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0, 0.4, 0.8) );\n        vec3 ff = texcube( iChannel1, 0.1*vec3(pos.x,4.0*res.z-pos.y,pos.z), nor ).xyz;\n        col *= ff.x;\n\n        \/\/ lighting\n        col = doLighting( col, ff.x, pos, nor, rd );\n        col *= 1.0 - smoothstep( 20.0, 40.0, t );\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture2D( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture2D( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture2D( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture2D( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n    \/\/-----------\n    float time = 5.0 + 0.2*iGlobalTime + 20.0*iMouse.x\/iResolution.x;\n\n    vec3 tot = vec3(0.0);\n    #ifdef ANTIALIAS\n    for( int i=0; i<4; i++ )\n    {\n        vec2 off = vec2( mod(float(i),2.0), mod(float(i\/2),2.0) )\/2.0;\n    #else\n        vec2 off = vec2(0.0);\n    #endif        \n        vec2 xy = (-iResolution.xy+2.0*(fragCoord.xy+off)) \/ iResolution.y;\n\n        \/\/ camera\t\n        vec3 ro = vec3( 8.5*cos(0.2+.33*time), 5.0+2.0*cos(0.1*time), 8.5*sin(0.1+0.37*time) );\n        vec3 ta = vec3( -2.5+3.0*cos(1.2+.41*time), 0.0, 2.0+3.0*sin(2.0+0.38*time) );\n        float roll = 0.2*sin(0.1*time);\n\n        \/\/ camera tx\n        mat3 ca = setLookAt( ro, ta, roll );\n        vec3 rd = normalize( ca * vec3(xy.xy,1.75) );\n        \n        vec3 col = render( ro, rd );\n        \n        tot += pow( col, vec3(0.4545) );\n    #ifdef ANTIALIAS\n    }\n\ttot \/= 4.0;\n    #endif    \n    \n    \/\/ vigneting\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    tot *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor=vec4( tot, 1.0 );\n\n\n\n\n}\n\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfreqs[0] = texture2D( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture2D( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture2D( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture2D( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n    vec3 col = render( fragRayOri + vec3(0.0,4.0,0.0), fragRayDir );\n\n    col += pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dXGR4","date":"1363057754","viewed":28045,"name":"Main Sequence Star","username":"flight404","description":"Inspired by trisomie21's 3d noise fireball, I made some tweaks and ended up with a star.<br\/><br\/>EDIT: Fixed the negative sqrt issue as per iq's suggestion.","likes":252,"published":1,"flags":0,"tags":["3dnoise","perlin","star","corona"],"hasliked":0},"renderpass":[{"inputs":[{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":13,"src":"\/presets\/mzk00.mp3","ctype":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"outputs":[{"channel":"0","dst":"-1"},{"channel":"0","dst":"-1"}],"code":"\/\/ based on https:\/\/www.shadertoy.com\/view\/lsf3RH by\r\n\/\/ trisomie21 (THANKS!)\r\n\/\/ My apologies for the ugly code.\r\n\r\nfloat snoise(vec3 uv, float res)\t\/\/ by trisomie21\r\n{\r\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\r\n\t\r\n\tuv *= res;\r\n\t\r\n\tvec3 uv0 = floor(mod(uv, res))*s;\r\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\r\n\t\r\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\r\n\t\r\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\r\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\r\n\t\r\n\tvec4 r = fract(sin(v*1e-3)*1e5);\r\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\t\r\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\r\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\t\r\n\treturn mix(r0, r1, f.z)*2.-1.;\r\n}\r\n\r\nfloat freqs[4];\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfreqs[0] = texture2D( iChannel1, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture2D( iChannel1, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture2D( iChannel1, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture2D( iChannel1, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\r\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\r\n\tfloat invRadius \t= 1.0\/radius;\r\n\t\r\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\r\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\r\n\tfloat time\t\t= iGlobalTime * 0.1;\r\n\tfloat aspect\t= iResolution.x\/iResolution.y;\r\n\tvec2 uv\t\t\t= fragCoord.xy \/ iResolution.xy;\r\n\tvec2 p \t\t\t= -0.5 + uv;\r\n\tp.x *= aspect;\r\n\r\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\r\n\tfloat fVal1\t\t= 1.0 - fade;\r\n\tfloat fVal2\t\t= 1.0 - fade;\r\n\t\r\n\tfloat angle\t\t= atan( p.x, p.y )\/6.2832;\r\n\tfloat dist\t\t= length(p);\r\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\r\n\t\r\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\r\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\r\n\tfor( int i=1; i<=7; i++ ){\r\n\t\tfloat power = pow( 2.0, float(i + 1) );\r\n\t\tfVal1 += ( 0.5 \/ power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\r\n\t\tfVal2 += ( 0.5 \/ power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\r\n\t}\r\n\t\r\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t*= 1.2 - newTime1;\r\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\r\n\tvec3 dir \t\t\t= vec3( 0.0 );\r\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\r\n\tvec3 starSphere\t\t= vec3( 0.0 );\r\n\t\r\n\tvec2 sp = -1.0 + 2.0 * uv;\r\n\tsp.x *= aspect;\r\n\tsp *= ( 2.0 - brightness );\r\n  \tfloat r = dot(sp,sp);\r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))\/(r) + brightness * 0.5;\r\n\tif( dist < radius ){\r\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\r\n  \t\tvec2 newUv;\r\n \t\tnewUv.x = sp.x*f;\r\n  \t\tnewUv.y = sp.y*f;\r\n\t\tnewUv += vec2( time, 0.0 );\r\n\t\t\r\n\t\tvec3 texSample \t= texture2D( iChannel0, newUv ).rgb;\r\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\r\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\r\n\t\tstarSphere\t\t= texture2D( iChannel0, starUV ).rgb;\r\n\t}\r\n\t\r\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\r\n\t\/\/fragColor.rgb\t= vec3( r );\r\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\r\n\tfragColor.a\t\t= 1.0;\r\n}\r\n\r\n","name":"","description":"","type":"image"}]}]